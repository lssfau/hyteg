copyright = '''\
/*
 * Copyright (c) 2024 Benjamin Mann.
 *
 * This file is part of HyTeG
 * (see https://i10git.cs.fau.de/hyteg/hyteg).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */\n\n
'''

import numpy as np
import sympy as sp
from scipy.special import comb


def basis_multiidx(dim, degree):
    # dimP = comb(dim + degree, degree, exact=True)
    α = []
    # 1d basis
    α = [(i, 0, 0) for i in range(degree + 1)]
    # 2d extension
    if dim > 1:
        α += [(i, j, 0) for i, _, _ in α for j in range(1, degree + 1 - i)]
    # 3d extension
    if dim > 2:
        α += [(i, j, k) for i, j, _ in α for k in range(1, degree + 1 - i - j)]

    return α


def basis_symbolic(α):
    x, y, z = sp.symbols("x y z")
    X = [x, y, z]
    Φ = []
    for i, j, k in α:
        φ = 1
        for px in range(i):
            φ *= X[0]
        for py in range(j):
            φ *= X[1]
        for pz in range(k):
            φ *= X[2]
        Φ.append(φ)
    return Φ


# coordinates for polynomial evaluation
# edge coordinates
def edge(n):
    # values scaled to yield better condition number for Vandermonde matrix
    # return np.linspace(-1, 1, n, dtype=np.float64) # optimal for 1d (just for completeness)
    # return np.linspace(-1, 2, n, dtype=np.float64) # optimal for 2d
    # return np.linspace(-1, 3.6, n, dtype=np.float64) # optimal for 3d
    return np.linspace(-1, 3, n, dtype=np.float64)  # reasonable compromise


# face coordinates
def face(n):
    x = edge(n)
    T = []
    for j in range(n):
        for i in range(n - j):
            T.append([x[i], x[j], 0])
    return np.array(T)


# tet coordinates
def cell(n):
    x = edge(n)
    T = []
    for k in range(n):
        for j in range(n - k):
            for i in range(n - j - k):
                T.append([x[i], x[j], x[k]])
    return np.array(T)


# vandermonde matrix and SVD
def vandermonde(dim, degree, lvl, verbose=False):
    assert 2 <= dim <= 3
    if verbose:
        print(f"construct Vandermonde matrix A for degree={degree}, lvl={lvl}, dim={dim}")
    # sample coordinates
    n = 2**lvl
    T = cell(n) if dim == 3 else face(n)
    # μx = np.mean(T[:, 0])
    # μy = np.mean(T[:, 1])
    # μz = np.mean(T[:, 2])
    # print(f"μ = ({μx}, {μy}, {μz})")
    # print(T)

    # basis functions
    α = basis_multiidx(dim, degree)
    # print(α)

    # Vandermonde matrix
    A = np.zeros((T.shape[0], len(α)), dtype=np.float64)
    for b in range(len(α)):
        i, j, k = α[b]
        # evaluate basis function at sample coordinates
        A[:, b] = T[:, 0] ** i * T[:, 1] ** j * T[:, 2] ** k
    # print(A)

    # SVD
    if verbose:
        print("compute SVD")
    U, S, Vh = np.linalg.svd(A, full_matrices=False)

    if verbose:
        print("return A, Uh, S^-1, V")
    return A, U.T.conj(), S**(-1), Vh.T.conj()


def write_matrix(f, M, name):
    r,c = M.shape
    f.write(f"   {name} = (Eigen::Matrix<double, {r}, {c}>() <<\n")
    for i in range(r):
        f.write("      " + ", ".join(f"{val:22.15e}" for val in M[i,:]))
        if i < r-1:
            f.write(",")
        f.write("\n")
    f.write("   ).finished();\n\n")

def write_vector(f, v, name):
    f.write(f"   {name} = (Eigen::Matrix<double, {len(v)}, 1>() <<\n")
    f.write("      " + ", ".join(f"{val:22.15e}" for val in v))
    f.write("\n   ).finished();\n\n")

def main():
    max_degree = 10
    max_lvl = lambda lvl: 7 if lvl == 2 else 5
    fname = f"leastSquares.cpp"

    with open(fname, "w") as f:
        # preamble
        f.write(copyright)
        f.write("/* This file was generated by generateVandermonde.py\n")
        f.write(" * Do not manually change anything!\n */\n\n")
        # f.write("#pragma once\n")
        f.write('#include "leastSquares.hpp"\n\n')

        # namespaces
        f.write("namespace hyteg {\n")
        f.write("namespace surrogate {\n")

        for dim in [2, 3]:
            for degree in range(1, max_degree + 1):
                for lvl in range(3, max_lvl(dim) + 1):
                    # compute Vandermonde matrix and SVD
                    A, Ut, Si, V = vandermonde(dim, degree, lvl, True)

                    # definition of LeastSquares ctor
                    f.write(f"LeastSquares<{dim}, {degree}, {lvl}>::LeastSquares(){{\n")

                    # write matrices
                    write_matrix(f, A, "A")
                    write_matrix(f, Ut, "Uh")
                    write_vector(f, Si, "Si")
                    write_matrix(f, V, "V")

                    # close ctor
                    f.write("}\n\n")

        # close namespaces
        f.write("} // namespace surrogate\n")
        f.write("} // namespace hyteg\n")


if __name__ == "__main__":
    main()


# A, U, S, V = vandermonde(3, 10, 4)
# print(A.shape)
# print(U.shape)
# print(S.shape)
# print(V.shape)
# print(f"κ = {S[0]/S[-1]:e}")
